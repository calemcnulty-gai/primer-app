This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-18T22:40:14.593Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
app/
  (tabs)/
    _layout.tsx
    explore.tsx
    index.tsx
    rtvi.tsx
  _layout.tsx
  +not-found.tsx
  index.tsx
components/
  __tests__/
    __snapshots__/
      ThemedText-test.tsx.snap
    ThemedText-test.tsx
  ui/
    IconSymbol.ios.tsx
    IconSymbol.tsx
    TabBarBackground.ios.tsx
    TabBarBackground.tsx
  Collapsible.tsx
  ErrorBoundary.tsx
  ExternalLink.tsx
  HapticTab.tsx
  HelloWave.tsx
  ParallaxScrollView.tsx
  PrimerContent.tsx
  RtviChat.tsx
  SplashScreen.tsx
  StoryPage.tsx
  ThemedText.tsx
  ThemedView.tsx
constants/
  Colors.ts
hooks/
  useRedux.ts
  useThemeColor.ts
scripts/
  reset-project.js
services/
  api.ts
store/
  slices/
    rtviSlice.ts
    storySlice.ts
  index.ts
theme/
  index.ts
  ThemeProvider.tsx
.gitignore
api-guide.md
app.config.js
app.json.backup
CLAUDE.md
package.json
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/(tabs)/_layout.tsx">
import { Tabs } from 'expo-router';
import React from 'react';
import { Platform } from 'react-native';
import { HapticTab } from '@/components/HapticTab';
import { IconSymbol } from '@/components/ui/IconSymbol';
import TabBarBackground from '@/components/ui/TabBarBackground';
import { useTheme } from '@/theme/ThemeProvider';
import ErrorBoundary from '@/components/ErrorBoundary';
export default function TabLayout() {
  const { colors } = useTheme();
  return (
    <ErrorBoundary>
      <Tabs
        screenOptions={{
          tabBarActiveTintColor: colors.tint,
          headerShown: false,
          tabBarButton: HapticTab,
          tabBarBackground: TabBarBackground,
          tabBarStyle: Platform.select({
            ios: {
              // Use a transparent background on iOS to show the blur effect
              position: 'absolute',
            },
            default: {},
          }),
        }}>
        <Tabs.Screen
          name="index"
          options={{
            title: 'Story',
            tabBarIcon: ({ color }) => <IconSymbol size={28} name="book.fill" color={color} />,
          }}
        />
        <Tabs.Screen
          name="rtvi"
          options={{
            title: 'RTVI',
            tabBarIcon: ({ color }) => <IconSymbol size={28} name="waveform.circle.fill" color={color} />,
          }}
        />
        <Tabs.Screen
          name="explore"
          options={{
            title: 'About',
            tabBarIcon: ({ color }) => <IconSymbol size={28} name="info.circle.fill" color={color} />,
          }}
        />
      </Tabs>
    </ErrorBoundary>
  );
}
</file>

<file path="app/(tabs)/explore.tsx">
import { StyleSheet, Image, Platform } from 'react-native';
import { Collapsible } from '@/components/Collapsible';
import { ExternalLink } from '@/components/ExternalLink';
import ParallaxScrollView from '@/components/ParallaxScrollView';
import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
import { IconSymbol } from '@/components/ui/IconSymbol';
export default function TabTwoScreen() {
  return (
    <ParallaxScrollView
      headerBackgroundColor={{ light: '#D0D0D0', dark: '#353636' }}
      headerImage={
        <IconSymbol
          size={310}
          color="#808080"
          name="chevron.left.forwardslash.chevron.right"
          style={styles.headerImage}
        />
      }>
      <ThemedView style={styles.titleContainer}>
        <ThemedText type="title">Explore</ThemedText>
      </ThemedView>
      <ThemedText>This app includes example code to help you get started.</ThemedText>
      <Collapsible title="File-based routing">
        <ThemedText>
          This app has two screens:{' '}
          <ThemedText type="defaultSemiBold">app/(tabs)/index.tsx</ThemedText> and{' '}
          <ThemedText type="defaultSemiBold">app/(tabs)/explore.tsx</ThemedText>
        </ThemedText>
        <ThemedText>
          The layout file in <ThemedText type="defaultSemiBold">app/(tabs)/_layout.tsx</ThemedText>{' '}
          sets up the tab navigator.
        </ThemedText>
        <ExternalLink href="https://docs.expo.dev/router/introduction">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Android, iOS, and web support">
        <ThemedText>
          You can open this project on Android, iOS, and the web. To open the web version, press{' '}
          <ThemedText type="defaultSemiBold">w</ThemedText> in the terminal running this project.
        </ThemedText>
      </Collapsible>
      <Collapsible title="Images">
        <ThemedText>
          For static images, you can use the <ThemedText type="defaultSemiBold">@2x</ThemedText> and{' '}
          <ThemedText type="defaultSemiBold">@3x</ThemedText> suffixes to provide files for
          different screen densities
        </ThemedText>
        <Image source={require('@/assets/images/react-logo.png')} style={{ alignSelf: 'center' }} />
        <ExternalLink href="https://reactnative.dev/docs/images">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Custom fonts">
        <ThemedText>
          Open <ThemedText type="defaultSemiBold">app/_layout.tsx</ThemedText> to see how to load{' '}
          <ThemedText style={{ fontFamily: 'SpaceMono' }}>
            custom fonts such as this one.
          </ThemedText>
        </ThemedText>
        <ExternalLink href="https://docs.expo.dev/versions/latest/sdk/font">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Light and dark mode components">
        <ThemedText>
          This template has light and dark mode support. The{' '}
          <ThemedText type="defaultSemiBold">useColorScheme()</ThemedText> hook lets you inspect
          what the user's current color scheme is, and so you can adjust UI colors accordingly.
        </ThemedText>
        <ExternalLink href="https://docs.expo.dev/develop/user-interface/color-themes/">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Animations">
        <ThemedText>
          This template includes an example of an animated component. The{' '}
          <ThemedText type="defaultSemiBold">components/HelloWave.tsx</ThemedText> component uses
          the powerful <ThemedText type="defaultSemiBold">react-native-reanimated</ThemedText>{' '}
          library to create a waving hand animation.
        </ThemedText>
        {Platform.select({
          ios: (
            <ThemedText>
              The <ThemedText type="defaultSemiBold">components/ParallaxScrollView.tsx</ThemedText>{' '}
              component provides a parallax effect for the header image.
            </ThemedText>
          ),
        })}
      </Collapsible>
    </ParallaxScrollView>
  );
}
const styles = StyleSheet.create({
  headerImage: {
    color: '#808080',
    bottom: -90,
    left: -35,
    position: 'absolute',
  },
  titleContainer: {
    flexDirection: 'row',
    gap: 8,
  },
});
</file>

<file path="app/(tabs)/index.tsx">
import { StyleSheet } from 'react-native';
import { StoryPage } from '@/components/StoryPage';
import { ThemedView } from '@/components/ThemedView';
import ErrorBoundary from '@/components/ErrorBoundary';
export default function HomeScreen() {
  return (
    <ErrorBoundary>
      <ThemedView style={styles.container}>
        <StoryPage />
      </ThemedView>
    </ErrorBoundary>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});
</file>

<file path="app/(tabs)/rtvi.tsx">
import { StyleSheet } from 'react-native';
import { RtviChat } from '@/components/RtviChat';
import { ThemedView } from '@/components/ThemedView';
import ErrorBoundary from '@/components/ErrorBoundary';
export default function RtviScreen() {
  return (
    <ErrorBoundary>
      <ThemedView style={styles.container}>
        <RtviChat />
      </ThemedView>
    </ErrorBoundary>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});
</file>

<file path="app/_layout.tsx">
import { DefaultTheme, ThemeProvider as NavigationThemeProvider } from '@react-navigation/native';
import { useFonts } from 'expo-font';
import { Stack } from 'expo-router';
import * as SplashScreen from 'expo-splash-screen';
import { StatusBar } from 'expo-status-bar';
import { useEffect } from 'react';
import 'react-native-reanimated';
import { Provider } from 'react-redux';
import { PersistGate } from 'redux-persist/integration/react';
import { ThemeProvider, useTheme } from '@/theme/ThemeProvider';
import { store, persistor } from '../store';
import { Colors } from '@/constants/Colors';
// Prevent the splash screen from auto-hiding before asset loading is complete.
SplashScreen.preventAutoHideAsync();
// Component to handle navigation theme
function NavigationTheme({ children }: { children: React.ReactNode }) {
  const { colors } = useTheme();
  // Customize navigation theme to match our e-ink theme
  const customNavigationTheme = {
    ...DefaultTheme,
    colors: {
      ...DefaultTheme.colors,
      background: colors.background,
      card: colors.background,
      text: colors.text,
      border: colors.separator,
      primary: colors.tint,
    },
  };
  return (
    <NavigationThemeProvider value={customNavigationTheme}>
      {children}
    </NavigationThemeProvider>
  );
}
export default function RootLayout() {
  const [loaded] = useFonts({
    SpaceMono: require('../assets/fonts/SpaceMono-Regular.ttf'),
  });
  useEffect(() => {
    if (loaded) {
      SplashScreen.hideAsync();
    }
  }, [loaded]);
  if (!loaded) {
    return null;
  }
  return (
    <Provider store={store}>
      <PersistGate loading={null} persistor={persistor}>
        <ThemeProvider>
          <NavigationTheme>
            <Stack screenOptions={{ headerShown: false, animation: 'fade' }}>
              <Stack.Screen name="index" />
            </Stack>
            <StatusBar style="dark" />
          </NavigationTheme>
        </ThemeProvider>
      </PersistGate>
    </Provider>
  );
}
</file>

<file path="app/+not-found.tsx">
import { Link, Stack } from 'expo-router';
import { StyleSheet } from 'react-native';
import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
export default function NotFoundScreen() {
  return (
    <>
      <Stack.Screen options={{ title: 'Oops!' }} />
      <ThemedView style={styles.container}>
        <ThemedText type="title">This screen doesn't exist.</ThemedText>
        <Link href="/" style={styles.link}>
          <ThemedText type="link">Go to home screen!</ThemedText>
        </Link>
      </ThemedView>
    </>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
});
</file>

<file path="app/index.tsx">
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, Platform } from 'react-native';
import { StatusBar } from 'expo-status-bar';
import { SplashScreen } from '@/components/SplashScreen';
import { useTheme } from '@/theme/ThemeProvider';
import { Redirect } from 'expo-router';
import ErrorBoundary from '@/components/ErrorBoundary';
export default function PrimerApp() {
  const { colors } = useTheme();
  const [showSplash, setShowSplash] = useState(true);
  const [readyToRedirect, setReadyToRedirect] = useState(false);
  const handleSplashFinish = () => {
    setShowSplash(false);
    // On Android, add a small delay before redirecting to give the app time to fully initialize
    if (Platform.OS === 'android') {
      setTimeout(() => {
        setReadyToRedirect(true);
      }, 1000);
    } else {
      setReadyToRedirect(true);
    }
  };
  // After splash screen, redirect to the tabbed interface with Story mode
  if (!showSplash && readyToRedirect) {
    return (
      <ErrorBoundary>
        <Redirect href="/(tabs)" />
      </ErrorBoundary>
    );
  }
  return (
    <ErrorBoundary>
      <View style={[styles.container, { backgroundColor: colors.background }]}>
        <StatusBar style="dark" />
        <SplashScreen onFinish={handleSplashFinish} />
      </View>
    </ErrorBoundary>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});
</file>

<file path="components/__tests__/__snapshots__/ThemedText-test.tsx.snap">
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`renders correctly 1`] = `
<Text
  style={
    [
      {
        "color": "#5b4636",
      },
      {
        "fontFamily": "SpaceMono",
        "fontSize": 16,
        "lineHeight": 24,
      },
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
    ]
  }
>
  Snapshot test!
</Text>
`;
</file>

<file path="components/__tests__/ThemedText-test.tsx">
import * as React from 'react';
import renderer from 'react-test-renderer';
import { ThemedText } from '../ThemedText';
import { ThemeProvider } from '@/theme/ThemeProvider';
it(`renders correctly`, () => {
  const tree = renderer.create(
    <ThemeProvider>
      <ThemedText>Snapshot test!</ThemedText>
    </ThemeProvider>
  ).toJSON();
  expect(tree).toMatchSnapshot();
});
</file>

<file path="components/ui/IconSymbol.ios.tsx">
import { SymbolView, SymbolViewProps, SymbolWeight } from 'expo-symbols';
import { StyleProp, ViewStyle } from 'react-native';
export function IconSymbol({
  name,
  size = 24,
  color,
  style,
  weight = 'regular',
}: {
  name: SymbolViewProps['name'];
  size?: number;
  color: string;
  style?: StyleProp<ViewStyle>;
  weight?: SymbolWeight;
}) {
  return (
    <SymbolView
      weight={weight}
      tintColor={color}
      resizeMode="scaleAspectFit"
      name={name}
      style={[
        {
          width: size,
          height: size,
        },
        style,
      ]}
    />
  );
}
</file>

<file path="components/ui/IconSymbol.tsx">
// This file is a fallback for using MaterialIcons on Android and web.
import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import { SymbolWeight } from 'expo-symbols';
import React from 'react';
import { OpaqueColorValue, StyleProp, ViewStyle, TextStyle } from 'react-native';
// Add your SFSymbol to MaterialIcons mappings here.
const MAPPING = {
  // See MaterialIcons here: https://icons.expo.fyi
  // See SF Symbols in the SF Symbols app on Mac.
  'house.fill': 'home',
  'paperplane.fill': 'send',
  'chevron.left.forwardslash.chevron.right': 'code',
  'chevron.right': 'chevron-right',
} as Partial<
  Record<
    import('expo-symbols').SymbolViewProps['name'],
    React.ComponentProps<typeof MaterialIcons>['name']
  >
>;
export type IconSymbolName = keyof typeof MAPPING;
/**
 * An icon component that uses native SFSymbols on iOS, and MaterialIcons on Android and web. This ensures a consistent look across platforms, and optimal resource usage.
 *
 * Icon `name`s are based on SFSymbols and require manual mapping to MaterialIcons.
 */
export function IconSymbol({
  name,
  size = 24,
  color,
  style,
}: {
  name: IconSymbolName;
  size?: number;
  color: string | OpaqueColorValue;
  style?: StyleProp<TextStyle>;
  weight?: SymbolWeight;
}) {
  return <MaterialIcons color={color} size={size} name={MAPPING[name]} style={style} />;
}
</file>

<file path="components/ui/TabBarBackground.ios.tsx">
import { useBottomTabBarHeight } from '@react-navigation/bottom-tabs';
import { BlurView } from 'expo-blur';
import { StyleSheet } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
export default function BlurTabBarBackground() {
  return (
    <BlurView
      // System chrome material automatically adapts to the system's theme
      // and matches the native tab bar appearance on iOS.
      tint="systemChromeMaterial"
      intensity={100}
      style={StyleSheet.absoluteFill}
    />
  );
}
export function useBottomTabOverflow() {
  const tabHeight = useBottomTabBarHeight();
  const { bottom } = useSafeAreaInsets();
  return tabHeight - bottom;
}
</file>

<file path="components/ui/TabBarBackground.tsx">
// This is a shim for web and Android where the tab bar is generally opaque.
export default undefined;
export function useBottomTabOverflow() {
  return 0;
}
</file>

<file path="components/Collapsible.tsx">
import { PropsWithChildren, useState } from 'react';
import { StyleSheet, TouchableOpacity } from 'react-native';
import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
import { IconSymbol } from '@/components/ui/IconSymbol';
import { Colors } from '@/constants/Colors';
export function Collapsible({ children, title }: PropsWithChildren & { title: string }) {
  const [isOpen, setIsOpen] = useState(false);
  return (
    <ThemedView>
      <TouchableOpacity
        style={styles.heading}
        onPress={() => setIsOpen((value) => !value)}
        activeOpacity={0.8}>
        <IconSymbol
          name="chevron.right"
          size={18}
          weight="medium"
          color={Colors.icon}
          style={{ transform: [{ rotate: isOpen ? '90deg' : '0deg' }] }}
        />
        <ThemedText type="defaultSemiBold">{title}</ThemedText>
      </TouchableOpacity>
      {isOpen && <ThemedView style={styles.content}>{children}</ThemedView>}
    </ThemedView>
  );
}
const styles = StyleSheet.create({
  heading: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  content: {
    marginTop: 6,
    marginLeft: 24,
  },
});
</file>

<file path="components/ErrorBoundary.tsx">
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { View, StyleSheet, TouchableOpacity, Platform } from 'react-native';
import { ThemedText } from './ThemedText';
import { ThemedView } from './ThemedView';
interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}
interface State {
  hasError: boolean;
  error: Error | null;
}
class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = {
      hasError: false,
      error: null
    };
  }
  static getDerivedStateFromError(error: Error): State {
    // Update state so the next render will show the fallback UI
    return { hasError: true, error };
  }
  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    // You can log the error to an error reporting service
    console.error("ErrorBoundary caught an error:", error, errorInfo);
  }
  resetError = (): void => {
    this.setState({ hasError: false, error: null });
  };
  render(): ReactNode {
    if (this.state.hasError) {
      // Custom fallback UI
      return this.props.fallback || (
        <ThemedView style={styles.container}>
          <ThemedText style={styles.title}>Something went wrong</ThemedText>
          <ThemedText style={styles.message}>
            {this.state.error?.toString() || "An unexpected error occurred"}
          </ThemedText>
          {Platform.OS === 'android' && (
            <ThemedText style={styles.androidNote}>
              This may be due to a network connectivity issue on Android.
            </ThemedText>
          )}
          <TouchableOpacity style={styles.button} onPress={this.resetError}>
            <ThemedText style={styles.buttonText}>Try Again</ThemedText>
          </TouchableOpacity>
        </ThemedView>
      );
    }
    return this.props.children;
  }
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  title: {
    fontSize: 22,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  message: {
    fontSize: 16,
    textAlign: 'center',
    marginBottom: 20,
  },
  androidNote: {
    fontSize: 14,
    fontStyle: 'italic',
    textAlign: 'center',
    marginBottom: 20,
    opacity: 0.7,
  },
  button: {
    backgroundColor: '#007AFF',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 8,
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
});
export default ErrorBoundary;
</file>

<file path="components/ExternalLink.tsx">
import { Link } from 'expo-router';
import { openBrowserAsync } from 'expo-web-browser';
import { type ComponentProps } from 'react';
import { Platform } from 'react-native';
type Props = Omit<ComponentProps<typeof Link>, 'href'> & { href: string };
export function ExternalLink({ href, ...rest }: Props) {
  return (
    <Link
      target="_blank"
      {...rest}
      href={href as any}
      onPress={async (event) => {
        if (Platform.OS !== 'web') {
          // Prevent the default behavior of linking to the default browser on native.
          event.preventDefault();
          // Open the link in an in-app browser.
          await openBrowserAsync(href);
        }
      }}
    />
  );
}
</file>

<file path="components/HapticTab.tsx">
import { BottomTabBarButtonProps } from '@react-navigation/bottom-tabs';
import { PlatformPressable } from '@react-navigation/elements';
import * as Haptics from 'expo-haptics';
export function HapticTab(props: BottomTabBarButtonProps) {
  return (
    <PlatformPressable
      {...props}
      onPressIn={(ev) => {
        if (process.env.EXPO_OS === 'ios') {
          // Add a soft haptic feedback when pressing down on the tabs.
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
        }
        props.onPressIn?.(ev);
      }}
    />
  );
}
</file>

<file path="components/HelloWave.tsx">
import { useEffect } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withRepeat,
  withSequence,
} from 'react-native-reanimated';
import { ThemedText } from '@/components/ThemedText';
export function HelloWave() {
  const rotationAnimation = useSharedValue(0);
  useEffect(() => {
    rotationAnimation.value = withRepeat(
      withSequence(withTiming(25, { duration: 150 }), withTiming(0, { duration: 150 })),
      4 // Run the animation 4 times
    );
  }, []);
  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotationAnimation.value}deg` }],
  }));
  return (
    <Animated.View style={animatedStyle}>
      <ThemedText style={styles.text}>👋</ThemedText>
    </Animated.View>
  );
}
const styles = StyleSheet.create({
  text: {
    fontSize: 28,
    lineHeight: 32,
    marginTop: -6,
  },
});
</file>

<file path="components/ParallaxScrollView.tsx">
import type { PropsWithChildren, ReactElement } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  interpolate,
  useAnimatedRef,
  useAnimatedStyle,
  useScrollViewOffset,
} from 'react-native-reanimated';
import { ThemedView } from '@/components/ThemedView';
import { useBottomTabOverflow } from '@/components/ui/TabBarBackground';
import { useTheme } from '@/theme/ThemeProvider';
const HEADER_HEIGHT = 250;
type Props = PropsWithChildren<{
  headerImage: ReactElement;
  headerBackgroundColor?: string;
}>;
export default function ParallaxScrollView({
  children,
  headerImage,
  headerBackgroundColor,
}: Props) {
  const { colors } = useTheme();
  const scrollRef = useAnimatedRef<Animated.ScrollView>();
  const scrollOffset = useScrollViewOffset(scrollRef);
  const bottom = useBottomTabOverflow();
  // Default e-ink theme header color if none provided
  const headerColor = headerBackgroundColor || colors.paperTexture;
  const headerAnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateY: interpolate(
            scrollOffset.value,
            [-HEADER_HEIGHT, 0, HEADER_HEIGHT],
            [-HEADER_HEIGHT / 2, 0, HEADER_HEIGHT * 0.75]
          ),
        },
        {
          scale: interpolate(scrollOffset.value, [-HEADER_HEIGHT, 0, HEADER_HEIGHT], [2, 1, 1]),
        },
      ],
    };
  });
  return (
    <ThemedView style={styles.container}>
      <Animated.ScrollView
        ref={scrollRef}
        scrollEventThrottle={16}
        scrollIndicatorInsets={{ bottom }}
        contentContainerStyle={{ paddingBottom: bottom }}>
        <Animated.View
          style={[
            styles.header,
            { backgroundColor: headerColor },
            headerAnimatedStyle,
          ]}>
          {headerImage}
        </Animated.View>
        <ThemedView style={styles.content}>{children}</ThemedView>
      </Animated.ScrollView>
    </ThemedView>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    height: HEADER_HEIGHT,
    overflow: 'hidden',
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0,0,0,0.1)',
  },
  content: {
    flex: 1,
    padding: 24,
    gap: 16,
    overflow: 'hidden',
  },
});
</file>

<file path="components/PrimerContent.tsx">
import React, { useEffect, useState } from 'react';
import { View, StyleSheet, ScrollView, ActivityIndicator } from 'react-native';
import { useTheme } from '@/theme/ThemeProvider';
import { ThemedText } from '@/components/ThemedText';
import api from '@/services/api';
export function PrimerContent() {
  const { colors } = useTheme();
  const [content, setContent] = useState<{ title: string; content: string } | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  useEffect(() => {
    const loadContent = async () => {
      try {
        setLoading(true);
        const data = await api.content.getContent();
        setContent(data);
        setError(null);
      } catch (err) {
        console.error('Error loading content:', err);
        setError('Failed to load your story. Please try again.');
        // Fallback content in case API fails
        setContent({
          title: "Chapter One",
          content: "Once upon a time, in a land both distant and near, a young girl discovered a most unusual book. The book was not like any other she had encountered before—its pages seemed to know her thoughts before she thought them, and it told stories that unfolded precisely as she needed them to.\n\nThe book was bound in leather that felt warm to the touch, embossed with intricate patterns that seemed to shift when viewed from different angles. Its pages were neither paper nor parchment, but something finer, like silk spun from knowledge itself.\n\n\"Welcome,\" the book seemed to whisper, though no sound emerged from its pages. \"I have been waiting for you.\""
        });
      } finally {
        setLoading(false);
      }
    };
    loadContent();
  }, []);
  if (loading) {
    return (
      <View style={[styles.container, styles.loadingContainer, { backgroundColor: colors.background }]}>
        <ActivityIndicator size="large" color={colors.tint} />
        <ThemedText style={styles.loadingText}>Opening your primer...</ThemedText>
      </View>
    );
  }
  return (
    <View style={[styles.container, { backgroundColor: colors.background }]}>
      <ScrollView contentContainerStyle={styles.scrollContent}>
        {error && (
          <View style={styles.errorContainer}>
            <ThemedText style={styles.errorText}>{error}</ThemedText>
          </View>
        )}
        <View style={styles.pageContainer}>
          <View style={[styles.pageContent, { backgroundColor: colors.paperTexture }]}>
            {content && (
              <>
                <ThemedText style={styles.title}>{content.title}</ThemedText>
                <View style={styles.decorativeDivider} />
                <ThemedText style={styles.bodyText}>{content.content}</ThemedText>
              </>
            )}
          </View>
        </View>
      </ScrollView>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  loadingContainer: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
  },
  errorContainer: {
    padding: 16,
    marginBottom: 16,
    backgroundColor: '#f8d7da',
    borderWidth: 1,
    borderColor: '#f5c6cb',
    borderRadius: 4,
  },
  errorText: {
    color: '#721c24',
    textAlign: 'center',
  },
  scrollContent: {
    flexGrow: 1,
    padding: 20,
  },
  pageContainer: {
    borderWidth: 1,
    borderColor: '#8a7b6b',
    backgroundColor: '#f8f3e8',
    borderRadius: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
    overflow: 'hidden',
  },
  pageContent: {
    padding: 24,
    minHeight: 500,
  },
  title: {
    fontSize: 24,
    textAlign: 'center',
    fontFamily: 'SpaceMono',
    marginBottom: 16,
  },
  decorativeDivider: {
    height: 1,
    backgroundColor: '#8a7b6b',
    marginVertical: 16,
    width: '100%',
  },
  bodyText: {
    fontSize: 16,
    lineHeight: 24,
    textAlign: 'justify',
    fontFamily: 'SpaceMono',
  },
});
</file>

<file path="components/RtviChat.tsx">
import React, { useEffect, useRef, useState } from 'react';
import { 
  View, 
  StyleSheet, 
  TextInput, 
  TouchableOpacity, 
  FlatList, 
  SafeAreaView,
  ActivityIndicator,
  KeyboardAvoidingView,
  Platform
} from 'react-native';
import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
import { useTheme } from '@/theme/ThemeProvider';
import { useAppDispatch, useAppSelector } from '@/hooks/useRedux';
import { 
  fetchConversation, 
  sendMessage, 
  startNewConversation, 
  setListening, 
  addLocalMessage 
} from '@/store/slices/rtviSlice';
import { RtviMessage } from '@/services/api';
import { IconSymbol } from '@/components/ui/IconSymbol';
export function RtviChat() {
  const { colors } = useTheme();
  const dispatch = useAppDispatch();
  const { conversation, isLoading, error, isListening } = useAppSelector((state) => state.rtvi);
  const [message, setMessage] = useState('');
  const flatListRef = useRef<FlatList>(null);
  const [isInitialized, setIsInitialized] = useState(false);
  // Load conversation on initial render with platform-specific timing
  useEffect(() => {
    // On Android, add a delay before fetching to avoid startup crashes
    if (Platform.OS === 'android') {
      const timer = setTimeout(() => {
        try {
          dispatch(fetchConversation());
          setIsInitialized(true);
        } catch (error) {
          console.error('Error initializing RTVI on Android:', error);
          // Don't mark as initialized on error to prevent further operations
        }
      }, 2000); // Increased delay to 2 seconds on Android
      return () => clearTimeout(timer);
    } else {
      // On iOS, fetch immediately
      dispatch(fetchConversation());
      setIsInitialized(true);
    }
  }, [dispatch]);
  // Scroll to bottom when conversation updates
  useEffect(() => {
    if (conversation.length > 0) {
      setTimeout(() => {
        flatListRef.current?.scrollToEnd({ animated: true });
      }, 100);
    }
  }, [conversation]);
  // Handle sending a message
  const handleSendMessage = async () => {
    if (message.trim() === '') return;
    // Add a temporary message to show immediately while the API call is in progress
    dispatch(addLocalMessage({
      content: message,
      timestamp: new Date().toISOString(),
      fromUser: true
    }));
    const trimmedMessage = message.trim();
    setMessage('');
    // Send actual message to the API
    dispatch(sendMessage(trimmedMessage));
  };
  // Handle starting a new conversation
  const handleNewConversation = () => {
    dispatch(startNewConversation());
  };
  // Toggle listening mode
  const toggleListening = () => {
    dispatch(setListening(!isListening));
    // In a real app, this would integrate with voice recognition
    // For now, we'll just simulate the UI changes
  };
  // Render a chat message
  const renderMessage = ({ item }: { item: RtviMessage }) => {
    const isUser = item.fromUser;
    return (
      <View style={[
        styles.messageContainer,
        isUser ? styles.userMessageContainer : styles.botMessageContainer,
      ]}>
        <ThemedView 
          style={[
            styles.messageBubble,
            isUser ? styles.userMessageBubble : styles.botMessageBubble,
            { backgroundColor: isUser ? colors.primary : colors.card }
          ]}
        >
          <ThemedText 
            style={[
              styles.messageText,
              isUser && { color: '#FFFFFF' }
            ]}
          >
            {item.content}
          </ThemedText>
        </ThemedView>
      </View>
    );
  };
  return (
    <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]}>
      <KeyboardAvoidingView 
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardAvoidingView}
      >
        <View style={styles.header}>
          <ThemedText style={styles.headerTitle}>RTVI</ThemedText>
          <TouchableOpacity 
            style={styles.newChatButton}
            onPress={handleNewConversation}
          >
            <ThemedText style={styles.newChatButtonText}>New Chat</ThemedText>
          </TouchableOpacity>
        </View>
        {error && (
          <View style={styles.errorContainer}>
            <ThemedText style={styles.errorText}>{error}</ThemedText>
            <TouchableOpacity 
              style={styles.retryButton}
              onPress={() => dispatch(fetchConversation())}
            >
              <ThemedText style={styles.retryButtonText}>Retry</ThemedText>
            </TouchableOpacity>
          </View>
        )}
        <FlatList
          ref={flatListRef}
          data={conversation}
          renderItem={renderMessage}
          keyExtractor={(item) => item.id}
          contentContainerStyle={styles.messageList}
          ListEmptyComponent={() => (
            <View style={styles.emptyContainer}>
              <IconSymbol
                size={60}
                color={colors.text}
                name="waveform"
                style={styles.emptyIcon}
              />
              <ThemedText style={styles.emptyText}>
                Start a conversation with your Primer
              </ThemedText>
            </View>
          )}
        />
        <View style={styles.inputContainer}>
          <TextInput
            style={[
              styles.input,
              { 
                backgroundColor: colors.card, 
                color: colors.text,
                borderColor: colors.border
              }
            ]}
            placeholder="Ask your Primer something..."
            placeholderTextColor={colors.textDim}
            value={message}
            onChangeText={setMessage}
            onSubmitEditing={handleSendMessage}
            returnKeyType="send"
            editable={!isLoading}
          />
          <TouchableOpacity
            style={[
              styles.voiceButton,
              isListening && { backgroundColor: colors.primary }
            ]}
            onPress={toggleListening}
            disabled={isLoading}
          >
            <IconSymbol
              size={24}
              color={isListening ? '#FFFFFF' : colors.text}
              name="mic.fill"
            />
          </TouchableOpacity>
          <TouchableOpacity
            style={[
              styles.sendButton,
              { backgroundColor: colors.primary }
            ]}
            onPress={handleSendMessage}
            disabled={isLoading || message.trim() === ''}
          >
            {isLoading ? (
              <ActivityIndicator size="small" color="#FFFFFF" />
            ) : (
              <IconSymbol
                size={24}
                color="#FFFFFF"
                name="arrow.up"
              />
            )}
          </TouchableOpacity>
        </View>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  keyboardAvoidingView: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#E5E5E5',
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  newChatButton: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
    backgroundColor: '#F0F0F0',
  },
  newChatButtonText: {
    fontSize: 14,
    fontWeight: '500',
  },
  errorContainer: {
    margin: 16,
    padding: 16,
    borderRadius: 8,
    backgroundColor: '#FEE2E2',
    alignItems: 'center',
  },
  errorText: {
    color: '#B91C1C',
    marginBottom: 8,
  },
  retryButton: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 4,
    backgroundColor: '#B91C1C',
  },
  retryButtonText: {
    color: '#FFFFFF',
    fontWeight: '500',
  },
  messageList: {
    flexGrow: 1,
    padding: 16,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 100,
  },
  emptyIcon: {
    marginBottom: 16,
    opacity: 0.5,
  },
  emptyText: {
    fontSize: 16,
    opacity: 0.7,
    textAlign: 'center',
  },
  messageContainer: {
    marginBottom: 12,
    maxWidth: '80%',
  },
  userMessageContainer: {
    alignSelf: 'flex-end',
  },
  botMessageContainer: {
    alignSelf: 'flex-start',
  },
  messageBubble: {
    borderRadius: 16,
    paddingHorizontal: 16,
    paddingVertical: 10,
  },
  userMessageBubble: {
    borderBottomRightRadius: 4,
  },
  botMessageBubble: {
    borderBottomLeftRadius: 4,
  },
  messageText: {
    fontSize: 16,
  },
  inputContainer: {
    flexDirection: 'row',
    padding: 12,
    borderTopWidth: 1,
    borderTopColor: '#E5E5E5',
  },
  input: {
    flex: 1,
    height: 48,
    borderRadius: 24,
    paddingHorizontal: 16,
    borderWidth: 1,
    marginRight: 8,
  },
  voiceButton: {
    width: 48,
    height: 48,
    borderRadius: 24,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 8,
    backgroundColor: '#F0F0F0',
  },
  sendButton: {
    width: 48,
    height: 48,
    borderRadius: 24,
    justifyContent: 'center',
    alignItems: 'center',
  },
});
</file>

<file path="components/SplashScreen.tsx">
import React, { useEffect } from 'react';
import { View, StyleSheet, Image, Animated } from 'react-native';
import { useTheme } from '@/theme/ThemeProvider';
import { ThemedText } from '@/components/ThemedText';
type SplashScreenProps = {
  onFinish: () => void;
};
export function SplashScreen({ onFinish }: SplashScreenProps) {
  const { colors } = useTheme();
  const fadeAnim = React.useRef(new Animated.Value(0)).current;
  const scaleAnim = React.useRef(new Animated.Value(0.9)).current;
  useEffect(() => {
    // Animation sequence
    Animated.sequence([
      // Fade in and scale up
      Animated.parallel([
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 1500,
          useNativeDriver: true,
        }),
        Animated.timing(scaleAnim, {
          toValue: 1,
          duration: 1500,
          useNativeDriver: true,
        }),
      ]),
      // Hold for a moment
      Animated.delay(1000),
      // Fade out
      Animated.timing(fadeAnim, {
        toValue: 0,
        duration: 800,
        useNativeDriver: true,
      }),
    ]).start(() => {
      // Call the onFinish callback when animations complete
      onFinish();
    });
  }, [fadeAnim, scaleAnim, onFinish]);
  return (
    <View style={[styles.container, { backgroundColor: colors.background }]}>
      <Animated.View
        style={[
          styles.content,
          {
            opacity: fadeAnim,
            transform: [{ scale: scaleAnim }],
          },
        ]}>
        <View style={styles.bookFrame}>
          <View style={[styles.bookCover, { backgroundColor: colors.paperTexture }]}>
            <ThemedText style={styles.title}>The Young Lady's</ThemedText>
            <ThemedText style={styles.subtitle}>Illustrated Primer</ThemedText>
            <View style={styles.decorativeLine} />
            <ThemedText style={styles.edition}>A Digital Edition</ThemedText>
          </View>
        </View>
      </Animated.View>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  content: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  bookFrame: {
    width: 280,
    height: 400,
    borderWidth: 2,
    borderColor: '#5b4636',
    padding: 15,
    backgroundColor: '#f8f3e8',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 6,
    elevation: 8,
  },
  bookCover: {
    flex: 1,
    borderWidth: 1,
    borderColor: '#8a7b6b',
    padding: 20,
    alignItems: 'center',
    justifyContent: 'center',
  },
  title: {
    fontSize: 28,
    textAlign: 'center',
    fontFamily: 'SpaceMono',
    marginBottom: 10,
  },
  subtitle: {
    fontSize: 24,
    textAlign: 'center',
    fontFamily: 'SpaceMono',
    marginBottom: 30,
  },
  decorativeLine: {
    width: 150,
    height: 2,
    backgroundColor: '#8a7b6b',
    marginBottom: 30,
  },
  edition: {
    fontSize: 14,
    fontFamily: 'SpaceMono',
    fontStyle: 'italic',
  },
});
</file>

<file path="components/StoryPage.tsx">
import React, { useEffect } from 'react';
import { View, StyleSheet, ScrollView, ActivityIndicator, TouchableOpacity, Animated, SafeAreaView } from 'react-native';
import { useTheme } from '@/theme/ThemeProvider';
import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
import { useAppDispatch, useAppSelector } from '@/hooks/useRedux';
import { fetchCurrentSegment, makeChoice, setTransitioning } from '@/store/slices/storySlice';
export function StoryPage() {
  const { colors } = useTheme();
  const dispatch = useAppDispatch();
  const { currentSegment, isLoading, error, isTransitioning } = useAppSelector((state) => state.story);
  const spinValue = React.useRef(new Animated.Value(0)).current;
  // Start the page turn animation
  const startPageTurnAnimation = () => {
    Animated.loop(
      Animated.timing(spinValue, {
        toValue: 1,
        duration: 1500,
        useNativeDriver: true,
      })
    ).start();
  };
  // Stop the page turn animation
  const stopPageTurnAnimation = () => {
    spinValue.stopAnimation();
    spinValue.setValue(0);
  };
  // Generate the page turn rotation
  const pageTurn = spinValue.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '360deg'],
  });
  // Load initial story segment
  useEffect(() => {
    dispatch(fetchCurrentSegment());
  }, [dispatch]);
  // Handle animation for loading states
  useEffect(() => {
    if (isLoading || isTransitioning) {
      startPageTurnAnimation();
    } else {
      stopPageTurnAnimation();
    }
  }, [isLoading, isTransitioning]);
  // Handle making a choice
  const handleChoiceSelect = (choiceId: string) => {
    dispatch(setTransitioning(true));
    dispatch(makeChoice(choiceId));
  };
  // Show loading indicator when transitioning between pages
  if (isLoading && !currentSegment) {
    return (
      <SafeAreaView style={[styles.container, styles.loadingContainer, { backgroundColor: colors.background }]}>
        <Animated.View style={{ transform: [{ rotate: pageTurn }] }}>
          <ThemedView style={styles.loadingIcon} variant="card" />
        </Animated.View>
        <ThemedText style={styles.loadingText}>Loading story from API...</ThemedText>
      </SafeAreaView>
    );
  }
  // If there's an error, display it prominently
  if (error) {
    return (
      <SafeAreaView style={[styles.container, styles.errorContainer, { backgroundColor: colors.background }]}>
        <ThemedText style={styles.errorTitle}>API Error</ThemedText>
        <ThemedText style={styles.errorText}>{error}</ThemedText>
        <TouchableOpacity 
          style={styles.retryButton}
          onPress={() => dispatch(fetchCurrentSegment())}
        >
          <ThemedText style={styles.retryButtonText}>Retry</ThemedText>
        </TouchableOpacity>
      </SafeAreaView>
    );
  }
  return (
    <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]}>
      <ScrollView contentContainerStyle={styles.scrollContent}>
        <View style={[styles.pageContent, { backgroundColor: colors.paperTexture }]}>
          {isTransitioning ? (
            <View style={styles.transitionContainer}>
              <Animated.View style={{ transform: [{ rotate: pageTurn }] }}>
                <ThemedView style={styles.loadingIcon} variant="card" />
              </Animated.View>
              <ThemedText style={styles.loadingText}>Turning page...</ThemedText>
            </View>
          ) : currentSegment ? (
            <>
              <ThemedText style={styles.title}>{currentSegment.title}</ThemedText>
              <View style={styles.decorativeDivider} />
              <ThemedText style={styles.bodyText}>{currentSegment.content}</ThemedText>
              {currentSegment.choices && currentSegment.choices.length > 0 && (
                <View style={styles.choicesContainer}>
                  <ThemedText style={styles.choiceHeader}>What will you do?</ThemedText>
                  {currentSegment.choices.map((choice) => (
                    <TouchableOpacity
                      key={choice.choiceId}
                      style={styles.choiceButton}
                      onPress={() => handleChoiceSelect(choice.choiceId)}
                    >
                      <ThemedText style={styles.choiceText}>{choice.text}</ThemedText>
                    </TouchableOpacity>
                  ))}
                </View>
              )}
            </>
          ) : null}
        </View>
      </ScrollView>
    </SafeAreaView>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  loadingContainer: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
  },
  loadingIcon: {
    width: 60,
    height: 80,
    borderRadius: 4,
  },
  transitionContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    minHeight: 300,
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 24,
  },
  errorTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    color: '#721c24',
    textAlign: 'center',
  },
  errorText: {
    fontSize: 16,
    color: '#721c24',
    textAlign: 'center',
    marginBottom: 24,
  },
  retryButton: {
    backgroundColor: '#343a40',
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
    marginTop: 16,
  },
  retryButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
    textAlign: 'center',
  },
  scrollContent: {
    flexGrow: 1,
  },
  pageContent: {
    flex: 1,
    padding: 24,
    minHeight: '100%',
  },
  title: {
    fontSize: 24,
    textAlign: 'center',
    fontFamily: 'SpaceMono',
    marginBottom: 16,
  },
  decorativeDivider: {
    height: 1,
    backgroundColor: '#8a7b6b',
    marginVertical: 16,
    width: '100%',
  },
  bodyText: {
    fontSize: 16,
    lineHeight: 24,
    textAlign: 'justify',
    fontFamily: 'SpaceMono',
  },
  choicesContainer: {
    marginTop: 32,
    gap: 12,
  },
  choiceHeader: {
    fontSize: 18,
    textAlign: 'center',
    fontFamily: 'SpaceMono',
    marginBottom: 8,
  },
  choiceButton: {
    backgroundColor: '#f0e6d2',
    borderWidth: 1,
    borderColor: '#8a7b6b',
    borderRadius: 4,
    padding: 12,
  },
  choiceText: {
    fontSize: 16,
    textAlign: 'center',
    fontFamily: 'SpaceMono',
  },
});
</file>

<file path="components/ThemedText.tsx">
import { Text, type TextProps, StyleSheet } from 'react-native';
import { useTheme } from '@/theme/ThemeProvider';
export type ThemedTextProps = TextProps & {
  customColor?: string;
  type?: 'default' | 'title' | 'defaultSemiBold' | 'subtitle' | 'link';
};
export function ThemedText({
  style,
  customColor,
  type = 'default',
  ...rest
}: ThemedTextProps) {
  const { colors } = useTheme();
  // Use provided color, otherwise use theme color
  const textColor = customColor || colors.text;
  return (
    <Text
      style={[
        { color: textColor },
        type === 'default' ? styles.default : undefined,
        type === 'title' ? styles.title : undefined,
        type === 'defaultSemiBold' ? styles.defaultSemiBold : undefined,
        type === 'subtitle' ? styles.subtitle : undefined,
        type === 'link' ? [styles.link, { color: colors.tint }] : undefined,
        style,
      ]}
      {...rest}
    />
  );
}
// Fonts styled to look good with the e-ink, paper-like theme
const styles = StyleSheet.create({
  default: {
    fontSize: 16,
    lineHeight: 24,
    fontFamily: 'SpaceMono',
  },
  defaultSemiBold: {
    fontSize: 16,
    lineHeight: 24,
    fontWeight: '600',
    fontFamily: 'SpaceMono',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    lineHeight: 32,
    fontFamily: 'SpaceMono',
  },
  subtitle: {
    fontSize: 20,
    fontWeight: 'bold',
    fontFamily: 'SpaceMono',
  },
  link: {
    lineHeight: 24,
    fontSize: 16,
    textDecorationLine: 'underline',
    fontFamily: 'SpaceMono',
  },
});
</file>

<file path="components/ThemedView.tsx">
import { View, type ViewProps, StyleSheet } from 'react-native';
import { useTheme } from '@/theme/ThemeProvider';
export type ThemedViewProps = ViewProps & {
  customColor?: string;
  variant?: 'default' | 'card' | 'paper';
};
export function ThemedView({ 
  style, 
  customColor, 
  variant = 'default',
  ...otherProps 
}: ThemedViewProps) {
  const { colors } = useTheme();
  // Use provided color, otherwise use theme color
  const backgroundColor = customColor || colors.background;
  // Apply variant-specific styling
  const getVariantStyle = () => {
    switch (variant) {
      case 'card':
        return styles.card;
      case 'paper':
        return styles.paper;
      default:
        return {};
    }
  };
  return (
    <View 
      style={[
        { backgroundColor }, 
        getVariantStyle(),
        variant === 'card' ? { borderColor: colors.separator } : undefined,
        variant === 'paper' ? { borderColor: colors.separator } : undefined,
        style
      ]} 
      {...otherProps} 
    />
  );
}
const styles = StyleSheet.create({
  card: {
    borderWidth: 1,
    borderRadius: 8,
    padding: 16,
    marginVertical: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  paper: {
    borderWidth: 1,
    borderRadius: 4,
    padding: 12,
    marginVertical: 4,
  }
});
</file>

<file path="constants/Colors.ts">
/**
 * Below are the colors for the e-ink themed app with a monochrome, sepia feel.
 * The colors are designed to mimic an e-reader experience with a warm, paper-like appearance.
 * There are many other ways to style your app. For example, [Nativewind](https://www.nativewind.dev/), [Tamagui](https://tamagui.dev/), [unistyles](https://reactnativeunistyles.vercel.app), etc.
 */
// E-ink sepia tones
const paperLight = '#f8f3e8'; // Light sepia paper color
const paperDark = '#e8e1d9';  // Slightly darker sepia
const inkColor = '#5b4636';   // Dark brown ink color
const accentSepia = '#b38a5b'; // Warm accent color
export const Colors = {
  text: inkColor,
  background: paperLight,
  tint: accentSepia,
  icon: '#8a7b6b',
  tabIconDefault: '#8a7b6b',
  tabIconSelected: inkColor,
  paperTexture: paperDark,  // For subtle texture elements
  separator: '#d9d0c1',     // Subtle separator color
};
</file>

<file path="hooks/useRedux.ts">
import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';
import type { RootState, AppDispatch } from '../store';
// Use throughout the app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
</file>

<file path="hooks/useThemeColor.ts">
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */
import { Colors } from '@/constants/Colors';
/**
 * Simple hook to access theme colors
 */
export function useThemeColor(colorName: keyof typeof Colors) {
  return Colors[colorName];
}
</file>

<file path="scripts/reset-project.js">
#!/usr/bin/env node
/**
 * This script is used to reset the project to a blank state.
 * It deletes or moves the /app, /components, /hooks, /scripts, and /constants directories to /app-example based on user input and creates a new /app directory with an index.tsx and _layout.tsx file.
 * You can remove the `reset-project` script from package.json and safely delete this file after running it.
 */
const fs = require("fs");
const path = require("path");
const readline = require("readline");
const root = process.cwd();
const oldDirs = ["app", "components", "hooks", "constants", "scripts"];
const exampleDir = "app-example";
const newAppDir = "app";
const exampleDirPath = path.join(root, exampleDir);
const indexContent = `import { Text, View } from "react-native";
export default function Index() {
  return (
    <View
      style={{
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Text>Edit app/index.tsx to edit this screen.</Text>
    </View>
  );
}
`;
const layoutContent = `import { Stack } from "expo-router";
export default function RootLayout() {
  return <Stack />;
}
`;
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
const moveDirectories = async (userInput) => {
  try {
    if (userInput === "y") {
      // Create the app-example directory
      await fs.promises.mkdir(exampleDirPath, { recursive: true });
      console.log(`📁 /${exampleDir} directory created.`);
    }
    // Move old directories to new app-example directory or delete them
    for (const dir of oldDirs) {
      const oldDirPath = path.join(root, dir);
      if (fs.existsSync(oldDirPath)) {
        if (userInput === "y") {
          const newDirPath = path.join(root, exampleDir, dir);
          await fs.promises.rename(oldDirPath, newDirPath);
          console.log(`➡️ /${dir} moved to /${exampleDir}/${dir}.`);
        } else {
          await fs.promises.rm(oldDirPath, { recursive: true, force: true });
          console.log(`❌ /${dir} deleted.`);
        }
      } else {
        console.log(`➡️ /${dir} does not exist, skipping.`);
      }
    }
    // Create new /app directory
    const newAppDirPath = path.join(root, newAppDir);
    await fs.promises.mkdir(newAppDirPath, { recursive: true });
    console.log("\n📁 New /app directory created.");
    // Create index.tsx
    const indexPath = path.join(newAppDirPath, "index.tsx");
    await fs.promises.writeFile(indexPath, indexContent);
    console.log("📄 app/index.tsx created.");
    // Create _layout.tsx
    const layoutPath = path.join(newAppDirPath, "_layout.tsx");
    await fs.promises.writeFile(layoutPath, layoutContent);
    console.log("📄 app/_layout.tsx created.");
    console.log("\n✅ Project reset complete. Next steps:");
    console.log(
      `1. Run \`npx expo start\` to start a development server.\n2. Edit app/index.tsx to edit the main screen.${
        userInput === "y"
          ? `\n3. Delete the /${exampleDir} directory when you're done referencing it.`
          : ""
      }`
    );
  } catch (error) {
    console.error(`❌ Error during script execution: ${error.message}`);
  }
};
rl.question(
  "Do you want to move existing files to /app-example instead of deleting them? (Y/n): ",
  (answer) => {
    const userInput = answer.trim().toLowerCase() || "y";
    if (userInput === "y" || userInput === "n") {
      moveDirectories(userInput).finally(() => rl.close());
    } else {
      console.log("❌ Invalid input. Please enter 'Y' or 'N'.");
      rl.close();
    }
  }
);
</file>

<file path="services/api.ts">
import Constants from 'expo-constants';
import { Alert, Platform } from 'react-native';
import * as Application from 'expo-application';
// API base URL from Expo constants
// For iOS simulator, localhost on the Mac is available as localhost:3000
// For Android emulator, use 10.0.2.2:3000 to access host's localhost
const getDevApiUrl = () => {
  if (Platform.OS === 'ios') {
    return 'http://localhost:3000';
  } else if (Platform.OS === 'android') {
    // On Android, we'll use a specific IP address if available, otherwise fall back to the emulator's localhost
    // Android's emulator mapping: 10.0.2.2 maps to the host's localhost
    try {
      // Check for explicit API_URL in Constants first
      if (Constants.expoConfig?.extra?.androidApiUrl) {
        return Constants.expoConfig.extra.androidApiUrl;
      }
      return 'http://10.0.2.2:3000';
    } catch (error) {
      console.error('Error getting Android API URL:', error);
      // Provide fallback URLs in case the primary one fails
      return 'http://10.0.2.2:3000';
    }
  } else {
    return 'http://localhost:3000';
  }
};
const API_URL = Constants.expoConfig?.extra?.apiUrl || getDevApiUrl();
// Add retry logic for network operations (especially important for Android)
const fetchWithRetry = async (url: string, options: RequestInit = {}, retries = 3, delay = 1000): Promise<Response> => {
  try {
    return await fetch(url, options);
  } catch (error) {
    if (retries <= 1) throw error;
    // Wait for the specified delay
    await new Promise(resolve => setTimeout(resolve, delay));
    // Retry with one less retry remaining
    return fetchWithRetry(url, options, retries - 1, delay * 1.5);
  }
};
// Get device ID for API requests
const getDeviceId = async (): Promise<string> => {
  let deviceId = '';
  if (Platform.OS === 'ios') {
    deviceId = await Application.getIosIdForVendorAsync() || '';
  } else if (Platform.OS === 'android') {
    deviceId = await Application.getAndroidId() || '';
  } else {
    // Web platform - generate a consistent ID and store in localStorage
    const storedId = localStorage.getItem('deviceId');
    if (storedId) {
      deviceId = storedId;
    } else {
      deviceId = `web-${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
      localStorage.setItem('deviceId', deviceId);
    }
  }
  return deviceId;
};
// Generic fetch function with error handling
async function apiFetch<T>(
  endpoint: string, 
  options: RequestInit = {}
): Promise<T> {
  try {
    const deviceId = await getDeviceId();
    // Merge default headers with provided options
    const mergedOptions: RequestInit = {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        'x-device-id': deviceId,
        ...options.headers,
      },
    };
    // Log request in development
    if (Constants.expoConfig?.extra?.environment === 'development') {
      console.log(`API Request: ${API_URL}${endpoint}`, {
        method: mergedOptions.method || 'GET',
        headers: mergedOptions.headers,
        body: mergedOptions.body ? JSON.parse(mergedOptions.body as string) : undefined
      });
    }
    // Use fetchWithRetry instead of fetch for better reliability on Android
    const response = await fetchWithRetry(`${API_URL}${endpoint}`, mergedOptions);
    // Log raw response in development
    if (Constants.expoConfig?.extra?.environment === 'development') {
      console.log(`API Raw Response: ${API_URL}${endpoint}`, {
        status: response.status,
        statusText: response.statusText,
        headers: Object.fromEntries([...response.headers.entries()])
      });
    }
    // Check for non-JSON responses or HTML error pages
    const contentType = response.headers.get('content-type');
    if (contentType && !contentType.includes('application/json')) {
      console.error(`Received non-JSON response with content type: ${contentType}`);
      throw new Error(`Unexpected response type: ${contentType}`);
    }
    // Parse JSON response
    const data = await response.json();
    // Log parsed response in development
    if (Constants.expoConfig?.extra?.environment === 'development') {
      console.log(`API Response Data: ${API_URL}${endpoint}`, data);
    }
    // Check if response is ok
    if (!response.ok) {
      throw new Error(data.message || 'API request failed');
    }
    return data as T;
  } catch (error) {
    console.error('API request error:', error);
    // Add more detailed info to help debug connection issues
    if (error instanceof TypeError && error.message.includes('Network request failed')) {
      console.error(`Network request failed to ${API_URL}${endpoint}. Make sure your API server is running at ${API_URL}.`);
    }
    // Platform-specific error handling
    if (Platform.OS === 'android') {
      // On Android, some network errors might happen during initial startup
      // Return a graceful fallback instead of crashing
      if (endpoint.includes('/rtvi/conversation')) {
        console.log('Returning empty conversation for Android due to network error');
        return { 
          success: true, 
          conversation: [],
          message: {
            id: 'system-message',
            content: 'Connection temporarily unavailable. Please try again.',
            timestamp: new Date().toISOString(),
            fromUser: false
          }
        } as unknown as T;
      }
    }
    // Show alert with error message in development
    if (Constants.expoConfig?.extra?.environment === 'development') {
      let errorMessage = 'Unknown error';
      if (error instanceof Error) {
        errorMessage = error.message;
        if (error.message.includes('Network request failed')) {
          errorMessage += `\n\nMake sure your API server is running at ${API_URL}`;
        }
      }
      Alert.alert('API Error', errorMessage);
    }
    throw error;
  }
};
// Types for Story API responses
export interface StorySegment {
  segmentId: string;
  title: string;
  content: string;
  choices: StoryChoice[];
}
export interface StoryChoice {
  choiceId: string;
  text: string;
}
// New API response interfaces to match the server's format
export interface ApiSegment {
  id: string;
  content: string;
  choices: Array<{id: string; text: string}>;
}
export interface ApiStoryResponse {
  success: boolean;
  segment: ApiSegment;
  state: {
    userId: string;
    currentSegmentId: string;
    progress: number;
    contextualData: any;
    readSegments: string[];
    isConversationalMode: boolean;
    recentConversation: any[];
  };
}
export interface ApiResponse<T> {
  success: boolean;
  data: T;
  error?: string;
  message?: string;
}
// RTVI (Real-Time Voice Interaction) interfaces
export interface RtviMessage {
  id: string;
  content: string;
  timestamp: string;
  fromUser: boolean;
}
export interface RtviResponse {
  success: boolean;
  message: RtviMessage;
  conversation: RtviMessage[];
}
// API methods
export const api = {
  // Story related endpoints
  story: {
    // Get current story segment
    getCurrentSegment: async () => {
      return apiFetch<ApiStoryResponse>('/api/v1/story/current');
    },
    // Make a choice to progress the story
    makeChoice: async (choiceId: string) => {
      return apiFetch<ApiStoryResponse>('/api/v1/story/choice', {
        method: 'POST',
        body: JSON.stringify({ choiceId }),
      });
    },
    // Reset the story to the beginning
    resetStory: async () => {
      return apiFetch<ApiStoryResponse>('/api/v1/story/reset', {
        method: 'POST',
      });
    },
  },
  // User related endpoints (even though we don't have auth, we track device)
  user: {
    // Get or create user profile based on device ID
    getProfile: async () => {
      return apiFetch<{id: string; settings: any}>('/api/v1/user/profile');
    },
    // Update user settings
    updateSettings: async (settings: any) => {
      return apiFetch<{success: boolean}>('/api/v1/user/settings', {
        method: 'PUT',
        body: JSON.stringify(settings),
      });
    },
  },
  // RTVI (Real-Time Voice Interaction) endpoints
  rtvi: {
    // Get conversation history
    getConversation: async () => {
      return apiFetch<RtviResponse>('/api/v1/rtvi/conversation');
    },
    // Send a message to RTVI
    sendMessage: async (message: string) => {
      return apiFetch<RtviResponse>('/api/v1/rtvi/message', {
        method: 'POST',
        body: JSON.stringify({ message }),
      });
    },
    // Start a new RTVI conversation
    startNewConversation: async () => {
      return apiFetch<RtviResponse>('/api/v1/rtvi/new', {
        method: 'POST',
      });
    },
  },
};
export default api;
</file>

<file path="store/slices/rtviSlice.ts">
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { api, RtviMessage, RtviResponse } from '@/services/api';
// Define the initial state
interface RtviState {
  conversation: RtviMessage[];
  isLoading: boolean;
  error: string | null;
  isListening: boolean;
}
const initialState: RtviState = {
  conversation: [],
  isLoading: false,
  error: null,
  isListening: false,
};
// Async thunks
export const fetchConversation = createAsyncThunk(
  'rtvi/fetchConversation',
  async (_, { rejectWithValue }) => {
    try {
      const response = await api.rtvi.getConversation();
      if (!response.success) {
        return rejectWithValue('Failed to fetch conversation');
      }
      return response.conversation;
    } catch (error) {
      console.error('Error fetching RTVI conversation:', error);
      if (error instanceof Error) {
        return rejectWithValue(error.message);
      }
      return rejectWithValue('Failed to fetch RTVI conversation');
    }
  }
);
export const sendMessage = createAsyncThunk(
  'rtvi/sendMessage',
  async (message: string, { rejectWithValue }) => {
    try {
      const response = await api.rtvi.sendMessage(message);
      if (!response.success) {
        return rejectWithValue('Failed to send message');
      }
      return response;
    } catch (error) {
      console.error('Error sending RTVI message:', error);
      if (error instanceof Error) {
        return rejectWithValue(error.message);
      }
      return rejectWithValue('Failed to send RTVI message');
    }
  }
);
export const startNewConversation = createAsyncThunk(
  'rtvi/startNewConversation',
  async (_, { rejectWithValue }) => {
    try {
      const response = await api.rtvi.startNewConversation();
      if (!response.success) {
        return rejectWithValue('Failed to start new conversation');
      }
      return response.conversation;
    } catch (error) {
      console.error('Error starting new RTVI conversation:', error);
      if (error instanceof Error) {
        return rejectWithValue(error.message);
      }
      return rejectWithValue('Failed to start new RTVI conversation');
    }
  }
);
// Create the slice
const rtviSlice = createSlice({
  name: 'rtvi',
  initialState,
  reducers: {
    setListening: (state, action: PayloadAction<boolean>) => {
      state.isListening = action.payload;
    },
    addLocalMessage: (state, action: PayloadAction<Omit<RtviMessage, 'id'>>) => {
      const newMessage = {
        ...action.payload,
        id: `local-${Date.now()}`,
      };
      state.conversation.push(newMessage);
    },
  },
  extraReducers: (builder) => {
    // Handle fetchConversation
    builder
      .addCase(fetchConversation.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchConversation.fulfilled, (state, action) => {
        state.isLoading = false;
        state.conversation = action.payload;
      })
      .addCase(fetchConversation.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      });
    // Handle sendMessage
    builder
      .addCase(sendMessage.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(sendMessage.fulfilled, (state, action) => {
        state.isLoading = false;
        state.conversation = action.payload.conversation;
      })
      .addCase(sendMessage.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      });
    // Handle startNewConversation
    builder
      .addCase(startNewConversation.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(startNewConversation.fulfilled, (state, action) => {
        state.isLoading = false;
        state.conversation = action.payload;
      })
      .addCase(startNewConversation.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      });
  },
});
export const { setListening, addLocalMessage } = rtviSlice.actions;
export default rtviSlice.reducer;
</file>

<file path="store/slices/storySlice.ts">
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { api, StorySegment } from '@/services/api';
// Define the initial state
interface StoryState {
  currentSegment: StorySegment | null;
  isLoading: boolean;
  error: string | null;
  isTransitioning: boolean;
}
const initialState: StoryState = {
  currentSegment: null,
  isLoading: false,
  error: null,
  isTransitioning: false,
};
// Async thunks
export const fetchCurrentSegment = createAsyncThunk(
  'story/fetchCurrentSegment',
  async (_, { rejectWithValue }) => {
    try {
      const response = await api.story.getCurrentSegment();
      // Handle API response format with success/data fields
      if (response.success === false) {
        return rejectWithValue('Failed to fetch story segment');
      }
      if (response.data) {
        return response.data;
      }
      // Handle new API response format where segment is at the top level
      if (response.segment) {
        return {
          segmentId: response.segment.id,
          title: response.segment.id.charAt(0).toUpperCase() + response.segment.id.slice(1),
          content: response.segment.content,
          choices: response.segment.choices ? response.segment.choices.map(choice => ({
            choiceId: choice.id,
            text: choice.text
          })) : []
        };
      }
      return response;
    } catch (error) {
      console.error('Error fetching story segment:', error);
      if (error instanceof Error) {
        return rejectWithValue(error.message);
      }
      return rejectWithValue('Failed to fetch story segment');
    }
  }
);
export const makeChoice = createAsyncThunk(
  'story/makeChoice',
  async (choiceId: string, { rejectWithValue }) => {
    try {
      const response = await api.story.makeChoice(choiceId);
      // Handle API response format with success/data fields
      if (response.success === false) {
        return rejectWithValue('Failed to make choice');
      }
      if (response.data) {
        return response.data;
      }
      // Handle new API response format where segment is at the top level
      if (response.segment) {
        return {
          segmentId: response.segment.id,
          title: response.segment.id.charAt(0).toUpperCase() + response.segment.id.slice(1),
          content: response.segment.content,
          choices: response.segment.choices ? response.segment.choices.map(choice => ({
            choiceId: choice.id,
            text: choice.text
          })) : []
        };
      }
      return response;
    } catch (error) {
      console.error('Error making choice:', error);
      if (error instanceof Error) {
        return rejectWithValue(error.message);
      }
      return rejectWithValue('Failed to make choice');
    }
  }
);
export const resetStory = createAsyncThunk(
  'story/resetStory',
  async (_, { rejectWithValue }) => {
    try {
      const response = await api.story.resetStory();
      if (response.success === false) {
        return rejectWithValue('Failed to reset story');
      }
      if (response.data) {
        return response.data;
      }
      // Handle new API response format where segment is at the top level
      if (response.segment) {
        return {
          segmentId: response.segment.id,
          title: response.segment.id.charAt(0).toUpperCase() + response.segment.id.slice(1),
          content: response.segment.content,
          choices: response.segment.choices ? response.segment.choices.map(choice => ({
            choiceId: choice.id,
            text: choice.text
          })) : []
        };
      }
      return response;
    } catch (error) {
      if (error instanceof Error) {
        return rejectWithValue(error.message);
      }
      return rejectWithValue('Failed to reset story');
    }
  }
);
// Create the slice
const storySlice = createSlice({
  name: 'story',
  initialState,
  reducers: {
    setTransitioning: (state, action: PayloadAction<boolean>) => {
      state.isTransitioning = action.payload;
    },
  },
  extraReducers: (builder) => {
    // Handle fetchCurrentSegment
    builder
      .addCase(fetchCurrentSegment.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchCurrentSegment.fulfilled, (state, action) => {
        state.isLoading = false;
        state.currentSegment = action.payload;
      })
      .addCase(fetchCurrentSegment.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      });
    // Handle makeChoice
    builder
      .addCase(makeChoice.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(makeChoice.fulfilled, (state, action) => {
        state.isLoading = false;
        state.currentSegment = action.payload;
        state.isTransitioning = false;
      })
      .addCase(makeChoice.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
        state.isTransitioning = false;
      });
    // Handle resetStory
    builder
      .addCase(resetStory.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(resetStory.fulfilled, (state, action) => {
        state.isLoading = false;
        state.currentSegment = action.payload;
      })
      .addCase(resetStory.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      });
  },
});
export const { setTransitioning } = storySlice.actions;
export default storySlice.reducer;
</file>

<file path="store/index.ts">
import { configureStore } from '@reduxjs/toolkit';
import { combineReducers } from 'redux';
import { 
  persistStore,
  persistReducer,
  FLUSH,
  REHYDRATE,
  PAUSE,
  PERSIST,
  PURGE,
  REGISTER 
} from 'redux-persist';
import AsyncStorage from '@react-native-async-storage/async-storage';
// Dummy reducer to fix "Store does not have a valid reducer" error
const dummyReducer = (state = {}, action: any) => {
  return state;
};
// Configure redux-persist
const persistConfig = {
  key: 'root',
  storage: AsyncStorage,
  whitelist: ['story', 'rtvi'] // Persist story and rtvi state between app sessions
};
// Import reducers
import storyReducer from './slices/storySlice';
import rtviReducer from './slices/rtviSlice';
// Combine reducers
const rootReducer = combineReducers({
  // Add your reducers here
  dummy: dummyReducer,
  story: storyReducer,
  rtvi: rtviReducer
});
// Create persisted reducer
const persistedReducer = persistReducer(persistConfig, rootReducer);
// Configure store
export const store = configureStore({
  reducer: persistedReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],
      },
    }),
});
// Create persistor
export const persistor = persistStore(store);
// Export types
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
</file>

<file path="theme/index.ts">
export { ThemeProvider, useTheme } from './ThemeProvider';
</file>

<file path="theme/ThemeProvider.tsx">
import React, { createContext, useContext, ReactNode } from 'react';
import { Colors } from '@/constants/Colors';
// Create context with colors only
type ThemeContextType = {
  colors: typeof Colors;
};
const ThemeContext = createContext<ThemeContextType | undefined>(undefined);
// Theme provider props
type ThemeProviderProps = {
  children: ReactNode;
};
export const ThemeProvider = ({ children }: ThemeProviderProps) => {
  return (
    <ThemeContext.Provider
      value={{
        colors: Colors,
      }}
    >
      {children}
    </ThemeContext.Provider>
  );
};
// Custom hook to use the theme
export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};
</file>

<file path=".gitignore">
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

app-example
</file>

<file path="api-guide.md">
# Primer Server API Guide

This is a quick reference guide for client applications to interact with the Primer Server API.

## Base URL

All story-related API endpoints are prefixed with `/v1/story`.

## Authentication

Include the device ID in the `X-Device-ID` header with all requests:

```
X-Device-ID: your-unique-device-id
```

## API Endpoints

### Health Check
- `GET /health` - Check if the API is functioning correctly

### Story Endpoints
- `GET /v1/story/current` - Get the current story segment
- `POST /v1/story/choice` - Make a choice and progress the story
- `POST /v1/story/progress` - Update story progress and preferences
- `POST /v1/story/reset` - Reset the story to the beginning

### Conversational Story Endpoints
- `POST /v1/story/conversation/start` - Start a new conversational story
- `POST /v1/story/converse` - Continue a conversational story with user input

### Illustration Endpoints
- `GET /v1/story/illustrations/current` - Get illustrations for current segment
- `GET /v1/story/illustrations/segment/:segmentId` - Get illustrations for a specific segment
- `GET /v1/story/illustrations/search` - Search for illustrations by criteria
- `GET /v1/story/illustrations/:id` - Get a specific illustration by ID

### Monitoring Endpoints
- `GET /v1/monitoring/dashboard` - Get monitoring dashboard data
- `GET /v1/monitoring/gpt` - Get recent GPT usage metrics
- `GET /v1/monitoring/story` - Get recent story generation metrics
- `GET /v1/monitoring/user/:userId` - Get metrics for a specific user

## Common Request/Response Patterns

### Authentication
All requests should include the device ID:
```
X-Device-ID: your-unique-device-id
```

### Success Response Format
```json
{
  "success": true,
  "data": { ... }
}
```

### Error Response Format
```json
{
  "success": false,
  "error": "Error type",
  "message": "Detailed error message"
}
```

## Example Usage

### Starting a Story
1. Get the current story segment:
   ```
   GET /v1/story/current
   X-Device-ID: your-device-id
   ```

2. Make a choice:
   ```
   POST /v1/story/choice
   X-Device-ID: your-device-id
   Content-Type: application/json
   
   {
     "choiceId": "choice1"
   }
   ```

### Starting a Conversational Story
1. Start a conversation:
   ```
   POST /v1/story/conversation/start
   X-Device-ID: your-device-id
   Content-Type: application/json
   
   {
     "prompt": "A story about a space explorer",
     "preferences": {
       "genre": "sci-fi",
       "tone": "exciting"
     }
   }
   ```

2. Continue the conversation:
   ```
   POST /v1/story/converse
   X-Device-ID: your-device-id
   Content-Type: application/json
   
   {
     "message": "I want to explore the nearest planet",
     "conversationId": "conv-123456"
   }
   ```

### Getting Illustrations
```
GET /v1/story/illustrations/current
X-Device-ID: your-device-id
```

## Error Handling
Common HTTP status codes:
- `400` - Bad Request (missing or invalid parameters)
- `401` - Unauthorized (missing or invalid device ID)
- `404` - Not Found (resource not found)
- `500` - Internal Server Error

Always check the `success` field in the response to determine if the request was successful.
</file>

<file path="app.config.js">
const isProd = process.env.APP_ENV === 'production';
module.exports = {
  expo: {
    name: "The Primer",
    slug: "primer-app",
    version: "1.0.0",
    orientation: "portrait",
    icon: "./assets/images/icon.png",
    scheme: "myapp",
    userInterfaceStyle: "automatic",
    backgroundColor: "#f8f3e8",
    newArchEnabled: true,
    splash: {
      image: "./assets/images/splash-icon.png",
      resizeMode: "contain",
      backgroundColor: "#f8f3e8"
    },
    assetBundlePatterns: [
      "**/*"
    ],
    ios: {
      supportsTablet: true,
      infoPlist: {
        NSMicrophoneUsageDescription: "This app uses the microphone for voice interaction with your Primer."
      }
    },
    android: {
      adaptiveIcon: {
        foregroundImage: "./assets/images/adaptive-icon.png",
        backgroundColor: "#f8f3e8"
      },
      permissions: ["RECORD_AUDIO", "INTERNET"],
      config: {
        cleartextTraffic: true
      },
      package: "com.calemcnulty.primerapp"
    },
    web: {
      bundler: "metro",
      output: "static",
      favicon: "./assets/images/favicon.png"
    },
    plugins: [
      "expo-router",
      [
        "expo-av",
        {
          "microphonePermission": "Allow $(PRODUCT_NAME) to access your microphone for voice interaction."
        }
      ]
    ],
    experiments: {
      typedRoutes: true
    },
    extra: {
      apiUrl: isProd ? "https://primer.calemcnulty.com" : "",
      androidApiUrl: isProd ? "https://primer.calemcnulty.com" : "http://10.0.2.2:3000",
      environment: isProd ? "production" : "development"
    },
    updates: {
      enabled: false
    }
  }
};
</file>

<file path="app.json.backup">
{
  "expo": {
    "name": "The Primer",
    "slug": "primer-app",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "myapp",
    "userInterfaceStyle": "automatic",
    "backgroundColor": "#f8f3e8",
    "newArchEnabled": true,
    "splash": {
      "image": "./assets/images/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#f8f3e8"
    },
    "assetBundlePatterns": [
      "**/*"
    ],
    "ios": {
      "supportsTablet": true,
      "infoPlist": {
        "NSMicrophoneUsageDescription": "This app uses the microphone for voice interaction with your Primer."
      }
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/adaptive-icon.png",
        "backgroundColor": "#f8f3e8"
      },
      "permissions": ["RECORD_AUDIO"]
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-av",
        {
          "microphonePermission": "Allow $(PRODUCT_NAME) to access your microphone for voice interaction."
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true
    }
  }
}
</file>

<file path="CLAUDE.md">
# CLAUDE.md - Primer App Reference

## Build/Test Commands
- Start app: `npm run start` or `npx expo start`
- Dev mode: `npm run start:dev` (APP_ENV=development)
- Production: `npm run start:prod` (APP_ENV=production)
- Run tests: `npm test`
- Run single test: `npm test -- -t "test name pattern"`
- Platform specific: `npm run ios` or `npm run android`
- Linting: `npm run lint`
- Reset project: `npm run reset-project`

## Code Style Guidelines
- **TypeScript**: Use strict typing with explicit interfaces/types
- **Components**: Functional components with PascalCase naming
- **Imports**: React/RN first, third-party next, local imports last (using @/ alias)
- **State Management**: Redux with typed hooks (useAppDispatch, useAppSelector)
- **Styling**: Theme-aware components with StyleSheet.create()
- **Error Handling**: try/catch blocks with descriptive error messages
- **Testing**: Jest with snapshot testing
- **Expo**: Use `npx expo install` for package management
- **File Structure**: Platform-specific files use .ios.tsx/.android.tsx extensions

## Cursor Rules
- New packages must be installed with `npx expo install` instead of npm/yarn
</file>

<file path="package.json">
{
  "name": "primer-app",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "start:dev": "APP_ENV=development expo start",
    "start:prod": "APP_ENV=production expo start",
    "build:dev": "APP_ENV=development expo build",
    "build:prod": "APP_ENV=production expo build",
    "reset-project": "node ./scripts/reset-project.js",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "test": "jest",
    "lint": "expo lint"
  },
  "jest": {
    "preset": "jest-expo"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.0.2",
    "@react-native-async-storage/async-storage": "1.23.1",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@react-navigation/native": "^7.0.14",
    "@reduxjs/toolkit": "^2.6.1",
    "expo": "~52.0.38",
    "expo-application": "~6.0.2",
    "expo-av": "~15.0.2",
    "expo-blur": "~14.0.3",
    "expo-constants": "~17.0.8",
    "expo-font": "~13.0.4",
    "expo-haptics": "~14.0.1",
    "expo-linking": "~7.0.5",
    "expo-router": "~4.0.19",
    "expo-splash-screen": "~0.29.22",
    "expo-status-bar": "~2.0.1",
    "expo-symbols": "~0.2.2",
    "expo-system-ui": "~4.0.8",
    "expo-web-browser": "~14.0.2",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-native": "0.76.7",
    "react-native-gesture-handler": "~2.20.2",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "4.12.0",
    "react-native-screens": "~4.4.0",
    "react-native-web": "~0.19.13",
    "react-native-webview": "13.12.5",
    "react-redux": "^9.2.0",
    "redux-persist": "^6.0.0"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/jest": "^29.5.12",
    "@types/react": "~18.3.12",
    "@types/react-test-renderer": "^18.3.0",
    "jest": "^29.2.1",
    "jest-expo": "~52.0.6",
    "react-test-renderer": "18.3.1",
    "typescript": "^5.3.3"
  },
  "expo": {
    "doctor": {
      "reactNativeDirectoryCheck": {
        "exclude": ["redux-persist"]
      }
    }
  },
  "private": true
}
</file>

<file path="README.md">
# Welcome to your Expo app 👋

This is an [Expo](https://expo.dev) project created with [`create-expo-app`](https://www.npmjs.com/package/create-expo-app).

## Get started

1. Install dependencies

   ```bash
   npm install
   ```

2. Start the app

   ```bash
    npx expo start
   ```

In the output, you'll find options to open the app in a

- [development build](https://docs.expo.dev/develop/development-builds/introduction/)
- [Android emulator](https://docs.expo.dev/workflow/android-studio-emulator/)
- [iOS simulator](https://docs.expo.dev/workflow/ios-simulator/)
- [Expo Go](https://expo.dev/go), a limited sandbox for trying out app development with Expo

You can start developing by editing the files inside the **app** directory. This project uses [file-based routing](https://docs.expo.dev/router/introduction).

## Project Structure

This project follows a standard directory structure:

```
project_root/
 |-- .cursor/              # Cursor AI assistant configuration
 |     |-- rules/          # Composable rules for Cursor
 |     |-- project_plan.md # Task tracking
 |     |-- changelog.md    # Project changes log
 |
 |-- app/                  # Main application code
 |-- components/           # Reusable components
 |-- constants/            # Application constants
 |-- hooks/                # Custom React hooks
 |-- assets/               # Static assets
 |-- README.md             # This file
```

## Cursor Rules

This project uses a composable rule system for the Cursor AI assistant following Geoffrey Huntley's approach from [https://ghuntley.com/stdlib/](https://ghuntley.com/stdlib/). Rules are stored in `.cursor/rules/` and can be included in custom instructions using `@file:.cursor/rules/main.mdc`.

## Get a fresh project

When you're ready, run:

```bash
npm run reset-project
```

This command will move the starter code to the **app-example** directory and create a blank **app** directory where you can start developing.

## Learn more

To learn more about developing your project with Expo, look at the following resources:

- [Expo documentation](https://docs.expo.dev/): Learn fundamentals, or go into advanced topics with our [guides](https://docs.expo.dev/guides).
- [Learn Expo tutorial](https://docs.expo.dev/tutorial/introduction/): Follow a step-by-step tutorial where you'll create a project that runs on Android, iOS, and the web.

## Join the community

Join our community of developers creating universal apps.

- [Expo on GitHub](https://github.com/expo/expo): View our open source platform and contribute.
- [Discord community](https://chat.expo.dev): Chat with Expo users and ask questions.
</file>

<file path="tsconfig.json">
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts"
  ]
}
</file>

</files>
